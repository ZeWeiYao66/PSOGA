import scipy.stats as stats
import matplotlib.pyplot as plt
import numpy as np
from PGCloudlet import Cloudlet, Cloudlets
from PGComponent import Individual, Population
from PGOperator import Mutation, CrossOver
from PSOGA import Psoga
import time
import pickle

'''Step1：参数设置'''
K = 20      # 微云个数
N = 1000   # 迭代数目
Pnum = 100   # 种群数目
Rmut = 0.05  # 变异概率
w = 0.8  # 惯性权重
c1 = 2  # 学习因子
c2 = 2
serNum = [4, 7, 3, 2, 1, 3, 3, 3, 1, 5, 3, 1, 1, 5, 3, 4, 2, 4, 2, 4]
serRate = [6.02733, 6.0753, 5.73916, 5.44506, 4.36088, 2.53467, 4.3786, 3.32431, 3.33963, 9.30282, 5.76339, 5.4176,
           5.70676, 7.82355, 5.93078, 1.61441, 5.9464, 3.47075, 4.83307, 5.67262]
arrRate =  [13.9326, 15.75993, 13.14147, 3.24534, 1.93877, 2.14007, 6.79913, 7.59922, 0.19626, 5.56836, 13.499,
            4.59075, 5.24555, 23.83428, 3.77675, 3.36535, 10.01988, 9.11422, 6.7349, 11.45822]

'''Step2：对每个微云i的服务率，服务器数量，任务到达率,网络延时进行初始化'''
cloudlet = Cloudlet()  # 创建微云实例
cloudlets = Cloudlets(cloudlet, K)  # 创建微云集合实例
cloudlets.initialize()  # 初始化微云集合
np.set_printoptions(threshold=1e6)  # 取消用科学计数法输出数据
np.set_printoptions(suppress=True)
# 对微云进行参数赋值
for i in range(K):
    cloudlets.cloudlets[i].serverNum = serNum[i]
    cloudlets.cloudlets[i].serverRate = serRate[i]
    cloudlets.cloudlets[i].arrivalRate = arrRate[i]
cloudlets.C = [[0.0, 0.17519, 0.11937, 0.18421, 0.15582, 0.10069, 0.12142, 0.10927, 0.13545, 0.12042, 0.13496, 0.14622, 0.18458, 0.14052, 0.10845, 0.11507, 0.14583, 0.16796, 0.14905, 0.10378], [0.17519, 0.0, 0.18627, 0.18706, 0.17317, 0.10549, 0.10929, 0.15341, 0.11676, 0.16614, 0.16895, 0.18046, 0.16612, 0.16868, 0.1398, 0.11022, 0.15873, 0.16072, 0.17062, 0.18475], [0.11937, 0.18627, 0.0, 0.10514, 0.12885, 0.15305, 0.18322, 0.14847, 0.11932, 0.13468, 0.15157, 0.12749, 0.17438, 0.15577, 0.13434, 0.17118, 0.10933, 0.14785, 0.16228, 0.17471], [0.18421, 0.18706, 0.10514, 0.0, 0.10487, 0.18805, 0.14771, 0.16361, 0.18768, 0.19116, 0.16159, 0.1985, 0.16396, 0.16502, 0.15879, 0.15143, 0.16011, 0.14193, 0.16322, 0.17812], [0.15582, 0.17317, 0.12885, 0.10487, 0.0, 0.15994, 0.12174, 0.14582, 0.16714, 0.12516, 0.10487, 0.14981, 0.193, 0.13183, 0.16107, 0.19159, 0.18698, 0.14976, 0.18161, 0.14204], [0.10069, 0.10549, 0.15305, 0.18805, 0.15994, 0.0, 0.18513, 0.11461, 0.17706, 0.17393, 0.10178, 0.12966, 0.17404, 0.17497, 0.15173, 0.1833, 0.10712, 0.17616, 0.18232, 0.18505], [0.12142, 0.10929, 0.18322, 0.14771, 0.12174, 0.18513, 0.0, 0.16342, 0.14345, 0.10195, 0.10978, 0.10972, 0.17702, 0.12343, 0.15014, 0.1496, 0.13581, 0.12563, 0.19578, 0.12311], [0.10927, 0.15341, 0.14847, 0.16361, 0.14582, 0.11461, 0.16342, 0.0, 0.19257, 0.14678, 0.14659, 0.16453, 0.16306, 0.11247, 0.14332, 0.13265, 0.14776, 0.18727, 0.12057, 0.11389], [0.13545, 0.11676, 0.11932, 0.18768, 0.16714, 0.17706, 0.14345, 0.19257, 0.0, 0.14576, 0.15531, 0.11187, 0.16844, 0.16909, 0.18414, 0.15015, 0.11984, 0.13167, 0.15225, 0.16819], [0.12042, 0.16614, 0.13468, 0.19116, 0.12516, 0.17393, 0.10195, 0.14678, 0.14576, 0.0, 0.13256, 0.18286, 0.11386, 0.18136, 0.18035, 0.14958, 0.15599, 0.12686, 0.15646, 0.19158], [0.13496, 0.16895, 0.15157, 0.16159, 0.10487, 0.10178, 0.10978, 0.14659, 0.15531, 0.13256, 0.0, 0.13506, 0.17493, 0.18301, 0.14782, 0.11353, 0.17709, 0.10882, 0.18419, 0.15684], [0.14622, 0.18046, 0.12749, 0.1985, 0.14981, 0.12966, 0.10972, 0.16453, 0.11187, 0.18286, 0.13506, 0.0, 0.19071, 0.15253, 0.13692, 0.11557, 0.16031, 0.12606, 0.1328, 0.16022], [0.18458, 0.16612, 0.17438, 0.16396, 0.193, 0.17404, 0.17702, 0.16306, 0.16844, 0.11386, 0.17493, 0.19071, 0.0, 0.17276, 0.16973, 0.17266, 0.14456, 0.12407, 0.19527, 0.14766], [0.14052, 0.16868, 0.15577, 0.16502, 0.13183, 0.17497, 0.12343, 0.11247, 0.16909, 0.18136, 0.18301, 0.15253, 0.17276, 0.0, 0.13081, 0.13662, 0.1342, 0.17633, 0.16444, 0.11791], [0.10845, 0.1398, 0.13434, 0.15879, 0.16107, 0.15173, 0.15014, 0.14332, 0.18414, 0.18035, 0.14782, 0.13692, 0.16973, 0.13081, 0.0, 0.1018, 0.15448, 0.13475, 0.10394, 0.15434], [0.11507, 0.11022, 0.17118, 0.15143, 0.19159, 0.1833, 0.1496, 0.13265, 0.15015, 0.14958, 0.11353, 0.11557, 0.17266, 0.13662, 0.1018, 0.0, 0.13116, 0.17873, 0.16945, 0.14589], [0.14583, 0.15873, 0.10933, 0.16011, 0.18698, 0.10712, 0.13581, 0.14776, 0.11984, 0.15599, 0.17709, 0.16031, 0.14456, 0.1342, 0.15448, 0.13116, 0.0, 0.15958, 0.19617, 0.18624], [0.16796, 0.16072, 0.14785, 0.14193, 0.14976, 0.17616, 0.12563, 0.18727, 0.13167, 0.12686, 0.10882, 0.12606, 0.12407, 0.17633, 0.13475, 0.17873, 0.15958, 0.0, 0.12754, 0.11007], [0.14905, 0.17062, 0.16228, 0.16322, 0.18161, 0.18232, 0.19578, 0.12057, 0.15225, 0.15646, 0.18419, 0.1328, 0.19527, 0.16444, 0.10394, 0.16945, 0.19617, 0.12754, 0.0, 0.17683], [0.10378, 0.18475, 0.17471, 0.17812, 0.14204, 0.18505, 0.12311, 0.11389, 0.16819, 0.19158, 0.15684, 0.16022, 0.14766, 0.11791, 0.15434, 0.14589, 0.18624, 0.11007, 0.17683, 0.0]]
'''Step3：计算每个微云的本地任务响应时间'''
waitTimes = cloudlets.CalWaitTimes()
print('所有微云的本地任务响应时间: ', waitTimes)
print('其中最大的本地任务响应时间: ', max(waitTimes))
# 按照微云的本地任务响应时间进行排序
waitTimes_sorted = np.sort(waitTimes)
'''Step4：按照微云的本地任务响应时间，将K个微云划分成过载和不过载的微云.'''
fitness = []  # 存放适应度值
result = []  # 存放每一次划分的结果
start_time = time.time()
for i in range(1, K-1):
    OverCloudlet = []  # 过载微云的序号集合
    UnderCloudlet = []  # 不过载微云的序号集合
    Tp = waitTimes_sorted[i]  # 用作划分微云集合的微云p的本地任务响应时间
    # 将微云划分成两个集合
    for j in range(K):
        # 过载集合
        if waitTimes[j] > Tp:
            OverCloudlet.append(j)
        # 不过载集合
        else:
            UnderCloudlet.append(j)
    print('第 ' + str(i) + ' 次')
    print('过载微云集合:  ', OverCloudlet)
    print('不过载微云集合:', UnderCloudlet)
    '''Step5：初始化粒子的解（也即任务流g）,计算适应值，并进行迭代'''
    I = Individual()  # 单个粒子
    P = Population(I, cloudlets, OverCloudlet, UnderCloudlet, Pnum, w)  # 种群(粒子集合)
    # print(P.gbestFitness)
    M = Mutation(Rmut)  # 变异操作
    C = CrossOver()     # 交叉操作
    psoga = Psoga(P, M, C)
    bestResult, fit = psoga.run(N)  # 运行主算法，获得每一次划分的最优解及其适应度
    result.append(bestResult)
    fitness.append(fit)
end_time = time.time()
print('total time outside:', end_time - start_time)
'''Step6：从result中计算最优解'''
best_index = np.argmin(fitness)  # 获取最优结果的下标
print(fitness[best_index])  # 打印最优适应度值
print(result[best_index])  # 打印最优解
